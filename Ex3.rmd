---
title: "Exercise 3"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Install packages 
to read parquet file + race + gender

## Load libraries

```{r }
library(tidyverse)
library(igraph)
library(tidygraph)
library(ggraph)
library(readr)
library(lubridate)
library(arrow)
library(gender)
library(wru)
library(ggplot2)
library(gridExtra)
library(grid)
```


## Load data
```{r }
applications <- read_parquet(paste0("app_data_sample.parquet"))
edges <- read_csv("edges_sample.csv")
head(edges)
head(applications)
```


## Get gender for examiners

get names without repetition:

```{r gender-1}
examiner_names <- applications %>% 
  distinct(examiner_name_first)
```

Attach a gender and probability to each name and put the results into the table `examiner_names_gender`

```{r gender-2}
# get a table of names and gender
examiner_names_gender <- examiner_names %>% 
  do(results = gender(.$examiner_name_first, method = "ssa")) %>% 
  unnest(cols = c(results), keep_empty = TRUE) %>% 
  select(
    examiner_name_first = name,
    gender,
    proportion_female
  )
```

```{r gender-3}
# remove extra colums from the gender table
examiner_names_gender <- examiner_names_gender %>% 
  select(examiner_name_first, gender)
# joining gender back to the dataset
applications <- applications %>% 
  left_join(examiner_names_gender, by = "examiner_name_first")
# cleaning up
rm(examiner_names)
rm(examiner_names_gender)
gc()
```

## Add race


```{r race-1}
examiner_surnames <- applications %>% 
  select(surname = examiner_name_last) %>% 
  distinct()
```


```{r race-2}
examiner_race <- predict_race(voter.file = examiner_surnames, surname.only = T) %>% 
  as_tibble()
```

Pick the race category that has the highest probability for each last name and then join the table back to the main applications table. 

```{r race-3}
examiner_race <- examiner_race %>% 
  mutate(max_race_p = pmax(pred.asi, pred.bla, pred.his, pred.oth, pred.whi)) %>% 
  mutate(race = case_when(
    max_race_p == pred.asi ~ "Asian",
    max_race_p == pred.bla ~ "black",
    max_race_p == pred.his ~ "Hispanic",
    max_race_p == pred.oth ~ "other",
    max_race_p == pred.whi ~ "white",
    TRUE ~ NA_character_
  ))
```

Join the data back to the applications table.

```{r race-4}
# removing extra columns
examiner_race <- examiner_race %>% 
  select(surname,race)
applications <- applications %>% 
  left_join(examiner_race, by = c("examiner_name_last" = "surname"))
rm(examiner_race)
rm(examiner_surnames)
gc()
```
## Add tenure


```{r tenure-1}
examiner_dates <- applications %>% 
  select(examiner_id, filing_date, appl_status_date) 
```

Make dates format consistent (create new variables `start_date` and `end_date')

```{r tenure-2}
examiner_dates <- examiner_dates %>% 
  mutate(start_date = ymd(filing_date), end_date = as_date(dmy_hms(appl_status_date)))
```

Identify the earliest and the latest date for each examiner and calculate the difference in days, which is their tenure in the organization.

```{r tenure-3}
examiner_dates <- examiner_dates %>% 
  group_by(examiner_id) %>% 
  summarise(
    earliest_date = min(start_date, na.rm = TRUE), 
    latest_date = max(end_date, na.rm = TRUE),
    tenure_days = interval(earliest_date, latest_date) %/% days(1)
    ) %>% 
  filter(year(latest_date)<2018)
```

Joining back to the applications data.

```{r tenure-4}
applications <- applications %>% 
  left_join(examiner_dates, by = "examiner_id")
rm(examiner_dates)
gc()
head(applications)
```

## Select and display subgroups
I selct subgroups with tenure dates covering 2008, when connections were made according to our edges_sample.csv

```{r }
group1 = applications[substr(applications$examiner_art_unit, 1,3)==164,]
summary(group1)

```
```{r }

chart1gender <- ggplot(data=group1, aes(x=gender)) +
  geom_bar(aes(y = (..count..)/sum(..count..)) )  +
  ylab("Proportion")+
  xlab("Gender")+
  ylim(0,1)+
  ggtitle(paste0("Gender - group1"))

chart1race <- ggplot(data=group1, aes(x=race)) +
  geom_bar(aes(y = (..count..)/sum(..count..)) )  +
  ylab("Proportion")+
  xlab("Race")+
  ylim(0,1)+
  ggtitle(paste0("Race - group1"))

chart1tenure <- ggplot(data=group1, aes(x=tenure_days)) +
  geom_bar(aes(y = (..count..)/sum(..count..)) )  +
  ylab("Proportion")+
  xlab("Tenure days")+
  ylim(0,0.01)+
  ggtitle(paste0("Tenure - group1"))
grid.arrange(chart1gender,chart1race,chart1tenure,ncol=2, widths=c(1,1))

```
Group1 rather equally distributed between male and female. Large proportion of White, followed by Asian.




```{r }
group2 = applications[substr(applications$examiner_art_unit, 1,3)==173,]
summary(group2)
```

```{r }

chart2gender <- ggplot(data=group2, aes(x=gender)) +
  geom_bar(aes(y = (..count..)/sum(..count..)) )  +
  ylab("Proportion")+
  xlab("Gender")+
  ylim(0,1)+
  ggtitle(paste0("Gender - group2"))

chart2race <- ggplot(data=group2, aes(x=race)) +
  geom_bar(aes(y = (..count..)/sum(..count..)) )  +
  ylab("Proportion")+
  xlab("Race")+
  ylim(0,1)+
  ggtitle(paste0("Gender - group2"))

chart2tenure <- ggplot(data=group2, aes(x=tenure_days)) +
  geom_bar(aes(y = (..count..)/sum(..count..)) )  +
  ylab("Proportion")+
  xlab("Tenure days")+
  ylim(0,0.01)+
  ggtitle(paste0("Tenure - group2"))
grid.arrange(chart2gender,chart2race,chart2tenure,ncol=2, widths=c(1,1))

```

Group2 largely skewed to Male. Same race distribution as Group 1, White predominant followed by Asian, then Black and Hispanic.

## Create and display advice network

Group1 and Group2 list nodes while the connections are provided in the edges_sample.csv. The individuals seeking advice are ego_examiner_id while those providing advice are alter_examiner_id.
We use nodes and edges to create network.

First we make our nodes dataframe with our two working groups 
```{r }
examiner_aus = distinct(subset(applications, select=c(examiner_art_unit, examiner_id)))
examiner_aus$wg = substr(examiner_aus$examiner_art_unit, 1,3)
examiner_aus = examiner_aus[examiner_aus$wg==164 | examiner_aus$wg==173,]
```

now we merge edges from csv and selected work groups, by the field "examiner id" both for ego and alter, and we keep only those of our two working groups
```{r }
network = merge(x=edges, y=examiner_aus, by.x="ego_examiner_id", by.y="examiner_id", all.x=TRUE)
network = network %>% rename(ego_art_unit=examiner_art_unit, ego_wg=wg)
network = drop_na(network)

network = merge(x=network, y=examiner_aus, by.x="alter_examiner_id", by.y="examiner_id", all.x=TRUE)
network = network %>% rename(alter_art_unit=examiner_art_unit, alter_wg=wg)
network = drop_na(network)
head(network)
#there are 1990 lines of advice
```





```{r }
egoNodes = subset(network, select=c(ego_examiner_id,ego_art_unit, ego_wg)) %>% rename(examiner_id=ego_examiner_id,art_unit=ego_art_unit,wg=ego_wg)
alterNodes = subset(network, select=c(alter_examiner_id,alter_art_unit, alter_wg))%>% rename(examiner_id=alter_examiner_id,art_unit=alter_art_unit,wg=alter_wg)
nodes = rbind(egoNodes, alterNodes)
nodes = distinct(nodes)

#there are 220 nodes but we get error related to duplicates so we get rid of those

nodes = nodes %>% group_by(examiner_id) %>% summarise(examiner_id=first(examiner_id), art_unit=first(art_unit), wg=first(wg))
nodes
#we now have 180 nodes
```
```{r }
network = graph_from_data_frame(d=network, vertices=nodes, directed=TRUE)
network
```
Display network

```{r }
graphnetwork <- ggraph(network, layout = "stress") +                                                                                                         
  geom_node_point(size = 2) +                                         
  geom_node_text(aes(label = ""), nudge_y = 0.05, nudge_x = 0.2)+ 
  geom_edge_link() +
  theme_void()
show(graphnetwork)
```

I do not understand what the clusters represent


## Calculate centrality scores




